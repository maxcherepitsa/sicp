#lang racket

; Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений?
; Какое поведение он увидит, если интерпретатор использует нормальный порядок?
; Объясните Ваш ответ.
; (Предполагается, что правило вычисления особой формы if одинаково независимо от того, какой порядок вычислений используется.
; Сначала вычисляется выражение-предикат, и результат определяет, нужно ли вычислять выражение-следствие или альтернативу.)


(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))

; Тут как раз сложнее всего было понять в тексте книги, но упражнение - отличный повод разобраться и скорее переходить к следующей главе.
;
; АППЛИКАТИВНЫЙ ПОРЯДОК
;
; Обратился к примерам из интернетов, нашелся вот такой толковый пример про аппликативный порядок:
;   double (average 2 4) =>
;   double (divide (plus 2 4) 2) =>
;   double (divide 6 2) =>
;   double 3 =>
;   plus 3 3 =>
;   6
;
; Грубо говоря, аппликативный, кажется "разворачивает" процедуру изнутри, считает "на ходу". Сначала считает аргументы, потом применяет процедуру.
; Вернусь к упражнению:
;
; (test 0 (p)) -> (test 0 p) -> (if (= x 0) 0 y) ///<- вот этот шаг не уверен/// -> (if (= 0 0) 0 p) -> 0  - отдает 0.
;
; НОРМАЛЬНЫЙ ПОРЯДОК
;
; Тоже пример из интернетов:
; double (average 2 4) =>
; plus (average 2 4) (average 2 4) =>
; plus (divide (plus 2 4) 2) (average 2 4) =>
; plus (divide 6 2) (average 2 4) =>
; plus 3 (average 2 4) =>
; plus 3 (divide (plus 2 4) 2) =>
; plus 3 (divide 6 2) =>
; plus 3 3 =>
; 6
;
; Нормальный разворачивает полностью, до элементарных выражений, до минимума процедур в тексте и потом уже считает.
; Менее эффективен тем, что проходясь потом по выражению, например, вида (+ (* 5 2) (* 5 2) (* 5 2)) будет 3 раза считать 5 * 2, как я понял
;
; К нашим баранам:
;
; (test 0 (p)) -> (if (= x 0) 0 (p)) -> (if (=0 0) 0 p) -> отдает 0 тоже.
;
;
; Такс, ого-го! Оказался неправ.
; В случае с аппликативным подходом, который используется в Scheme, интерпретатор бесконечно зацикливается на
; (test 0 (p)), так как (p) возвращает саму себя - (p)
;
; А вот в случае с нормальным порядком, начинаем разворачиваться и не задеваем (p) вообще, так как оно не считается до момента, пока до него не дошли, что в нашем случае = никогда
;
; (test 0 (p)) 
; (if (= 0 0) 0 (p)) 
; (if #t 0 (p))  
; 0
;
; Офигеть. Жаль, что решил неверно, зато осознал сейчас в полный рост. Как раз эту часть днем сегодня не понял до конца.